<!-- GTM Custom HTML Tag - MoveoOne Analytics (ES5 Compatible) -->
<script>
(function (window) {
    // Prevent multiple initializations
    if (window.MoveoOne) return;
    
    var API_URL = "https://dev-api.moveo.one/api/analytic/event/tag";
    var DOLPHIN_URL = "https://dolphin-prod-229920351162.europe-west1.run.app";
    var LIB_VERSION = "1.0.11"; // Constant library version - cannot be changed by client
    var LOGGING_ENABLED = false; // Enable/disable console logging
  
    /**
     * Core MoveoOne Web Tracker (ES5 Compatible)
     */
    function MoveoOneWeb(token) {
        this.token = token;
        this.buffer = [];
        this.flushInterval = 5000;
        this.maxThreshold = 100;
        this.context = "WEB_STATIC";
  
        // Use persistent session ID across page loads
        this.sessionId = this.getOrCreateSessionId();
        this.started = false;
        this.pendingUpdates = []; // Queue for updates before session starts
  
        // Predefined meta fields (optional, no defaults)
        // Note: libVersion is automatically added and cannot be changed
        this.meta = {
          libVersion: LIB_VERSION, // Always include library version
        };
  
        // Additional metadata - flexible key-value pairs
        this.additionalMeta = {};

        // Latency tracking configuration
        this.calculateLatency = true; // Default to true
  
        // Track viewport size for resize events
        this.currentViewport = {
          width: window.innerWidth,
          height: window.innerHeight,
        };
  
        // Check if this is a page navigation within an existing session
        this.isPageNavigation = this.checkIfPageNavigation();
  
        // Impression tracking state
        this.impressionObserver = null;
        // ES5 compatible alternative to WeakSet - using arrays with element tracking
        this.seenElements = []; // Elements currently in viewport
        this.appearedElements = []; // Elements that have actually appeared (sent appear event)
        this.trackedElements = []; // Track elements without DOM attributes
        this.trackedLinks = []; // Track links without DOM attributes
        this.trackedMedia = []; // Track media without DOM attributes
        this.pendingImpressions = []; // Queue for impression events before session starts
        this.pendingImmediateEvents = []; // Queue for immediate events before session starts
  
        // Start flush interval - ES5 compatible arrow function replacement
        var self = this;
        setInterval(function() { 
            self.flush(); 
        }, this.flushInterval);
    }

    // Helper method to get reliable path
    MoveoOneWeb.prototype.getCurrentPath = function() {
        var pathname = window.location.pathname;
        // Return "unknown" for empty string, null, or undefined
        return pathname && pathname.trim ? pathname.trim() : "unknown";
    };

    MoveoOneWeb.prototype.getPlatformInfo = function() {
        try {
          // Method 1: Try navigator.userAgentData (modern browsers)
          if (navigator.userAgentData && navigator.userAgentData.platform) {
            var platform = navigator.userAgentData.platform;
            if (platform && platform.trim && platform.trim() !== "") {
              return platform;
            }
          }

          // Method 2: Try navigator.platform (legacy, but still available)
          if (navigator.platform && navigator.platform.trim && navigator.platform.trim() !== "") {
            return navigator.platform;
          }

          // Method 3: Parse user agent string for platform detection
          var userAgent = navigator.userAgent;
          if (userAgent) {
            // Windows detection (various versions)
            if (userAgent.indexOf("Windows NT") !== -1) {
              return "Windows";
            }
            if (userAgent.indexOf("Windows") !== -1) {
              return "Windows";
            }
            
            // iOS detection (check BEFORE macOS since iOS includes "Mac OS X" in user agent)
            if (userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1) {
              return "iOS";
            }
            
            // macOS detection
            if (userAgent.indexOf("Mac OS X") !== -1 || userAgent.indexOf("Macintosh") !== -1) {
              return "macOS";
            }
            
            // Linux detection
            if (userAgent.indexOf("Linux") !== -1) {
              return "Linux";
            }
            
            // Android detection
            if (userAgent.indexOf("Android") !== -1) {
              return "Android";
            }
            
            // Chrome OS detection
            if (userAgent.indexOf("CrOS") !== -1) {
              return "Chrome OS";
            }
            
            // Firefox OS detection
            if (userAgent.indexOf("Firefox OS") !== -1) {
              return "Firefox OS";
            }
            
            // BlackBerry detection
            if (userAgent.indexOf("BlackBerry") !== -1) {
              return "BlackBerry";
            }
          }

          // Method 5: Try to detect from navigator properties
          if (navigator.appVersion) {
            var appVersion = navigator.appVersion.toLowerCase();
            if (appVersion.indexOf("win") !== -1) return "Windows";
            if (appVersion.indexOf("mac") !== -1) return "macOS";
            if (appVersion.indexOf("linux") !== -1) return "Linux";
            if (appVersion.indexOf("iphone") !== -1 || appVersion.indexOf("ipad") !== -1) return "iOS";
            if (appVersion.indexOf("android") !== -1) return "Android";
          }

          // Final fallback
          return "Unknown";
        } catch (error) {
          // If any error occurs during platform detection, return "Unknown"
          if (LOGGING_ENABLED) {
            console.warn("MoveoOne: Error during platform detection:", error);
          }
          return "Unknown";
        }
    };

    MoveoOneWeb.prototype.getLanguageInfo = function() {
        try {
          // Method 1: Try navigator.language (modern browsers)
          if (navigator.language && navigator.language.trim && navigator.language.trim() !== "") {
            return navigator.language;
          }

          // Method 2: Try navigator.userLanguage (legacy IE)
          if (navigator.userLanguage && navigator.userLanguage.trim && navigator.userLanguage.trim() !== "") {
            return navigator.userLanguage;
          }

          // Method 3: Try navigator.languages array
          if (navigator.languages && navigator.languages.length > 0) {
            var firstLanguage = navigator.languages[0];
            if (firstLanguage && firstLanguage.trim && firstLanguage.trim() !== "") {
              return firstLanguage;
            }
          }

          // Method 4: Try to extract from user agent
          var userAgent = navigator.userAgent;
          if (userAgent) {
            // Look for language patterns in user agent
            var langMatch = userAgent.match(/[a-z]{2}-[A-Z]{2}/);
            if (langMatch) {
              return langMatch[0];
            }
          }

          // Final fallback
          return "Unknown";
        } catch (error) {
          if (LOGGING_ENABLED) {
            console.warn("MoveoOne: Error during language detection:", error);
          }
          return "Unknown";
        }
    };

    // ES5 compatible WeakSet alternative methods
    MoveoOneWeb.prototype.addToArray = function(array, element) {
        if (array.indexOf(element) === -1) {
            array.push(element);
        }
    };

    MoveoOneWeb.prototype.hasInArray = function(array, element) {
        return array.indexOf(element) !== -1;
    };

    MoveoOneWeb.prototype.removeFromArray = function(array, element) {
        var index = array.indexOf(element);
        if (index !== -1) {
            array.splice(index, 1);
        }
    };

    // Robust timezone detection with fallbacks
    MoveoOneWeb.prototype.getTimezoneInfo = function() {
        try {
          // Method 1: Try Intl.DateTimeFormat (modern browsers)
          if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {
            var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            if (timezone && timezone.trim && timezone.trim() !== "") {
              return timezone;
            }
          }

          // Method 2: Try to get timezone offset and convert to timezone name
          var offset = new Date().getTimezoneOffset();
          if (offset !== undefined) {
            // Convert offset to timezone name
            var hours = Math.abs(Math.floor(offset / 60));
            var minutes = Math.abs(offset % 60);
            var sign = offset <= 0 ? '+' : '-';
            var hoursStr = hours.toString();
            var minutesStr = minutes.toString();
            // ES5 compatible padStart alternative
            if (hoursStr.length < 2) hoursStr = '0' + hoursStr;
            if (minutesStr.length < 2) minutesStr = '0' + minutesStr;
            return 'UTC' + sign + hoursStr + ':' + minutesStr;
          }

          // Method 3: Try to detect from date string
          var dateString = new Date().toString();
          var timezoneMatch = dateString.match(/\(([^)]+)\)/);
          if (timezoneMatch && timezoneMatch[1]) {
            return timezoneMatch[1];
          }

          // Final fallback
          return "Unknown";
        } catch (error) {
          if (LOGGING_ENABLED) {
            console.warn("MoveoOne: Error during timezone detection:", error);
          }
          return "Unknown";
        }
    };

    // Generate UUID for session IDs
    MoveoOneWeb.prototype.generateUUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
            /[xy]/g,
            function (c) {
                var r = (Math.random() * 16) | 0;
                var v = c === "x" ? r : (r & 0x3) | 0x8;
                return v.toString(16);
            }
        );
    };

    // Get existing session ID or create new one
    MoveoOneWeb.prototype.getOrCreateSessionId = function() {
        var storageKey = "moveo-session-id";
        var timestampKey = "moveo-session-timestamp";
        var sessionTimeout = 30 * 60 * 1000; // 30 minutes in milliseconds
  
        var existingSessionId = localStorage.getItem(storageKey);
        var sessionTimestamp = localStorage.getItem(timestampKey);
  
        // Check if existing session is still valid
        if (existingSessionId && sessionTimestamp) {
          var now = Date.now();
          var lastActivity = parseInt(sessionTimestamp, 10);
  
          if (now - lastActivity < sessionTimeout) {
            // Update timestamp for current activity
            localStorage.setItem(timestampKey, now.toString());
            this.isExistingSession = true;
            return existingSessionId;
          } else {
            // Session has expired - clear old session data
            localStorage.removeItem(storageKey);
            localStorage.removeItem(timestampKey);
          }
        }
  
        // Create new session
        this.isExistingSession = false;
        var newSessionId = this.generateUUID();
        localStorage.setItem(storageKey, newSessionId);
        localStorage.setItem(timestampKey, Date.now().toString());
  
        return newSessionId;
    };

    // Check if this is a page navigation within an existing session
    MoveoOneWeb.prototype.checkIfPageNavigation = function() {
        var lastPathKey = "moveo-last-path";
        var lastPath = localStorage.getItem(lastPathKey);
        var currentPath = this.getCurrentPath();
  
        // Store current path for next page load
        localStorage.setItem(lastPathKey, currentPath);
  
        // If we have a last path and it's different from current, it's navigation
        return lastPath && lastPath !== currentPath;
    };

    // Update session timestamp on activity
    MoveoOneWeb.prototype.updateSessionActivity = function() {
        var timestampKey = "moveo-session-timestamp";
        localStorage.setItem(timestampKey, Date.now().toString());
    };

    // Initialize method
    MoveoOneWeb.prototype.initialize = function() {
        // Prevent multiple initialize() calls
        if (this.initialized) {
          if (LOGGING_ENABLED) {
            console.warn("MoveoOne: Already initialized, ignoring duplicate initialize() call");
          }
          return;
        }
        
        this.initialized = true;
        
        // Pre-establish connection to prediction service for faster first predict request
        this.preconnectToPredictionService();
        
        // Start session asynchronously without blocking
        this.start();
  
        // Setup event listeners immediately
        this.setupClickTracking();
        this.setupDownloadOrOutboundLinkTracking();
        this.setupScrollTracking();
        this.setupFormTracking();
        this.setupHoverTracking();
        this.setupResizeTracking();
        this.setupPageUnloadTracking();
        this.setupMediaTracking();
        this.setupClipboardTracking();
  
        // Initialize impression tracking immediately (no longer waits for session)
        this.initImpressionObserver();
    };

    // Pre-establish connection to prediction service for faster first predict request
    MoveoOneWeb.prototype.preconnectToPredictionService = function() {
        try {
          // Extract domain from DOLPHIN_URL for preconnect
          var dolphinUrl = new URL(DOLPHIN_URL);
          var preconnectUrl = dolphinUrl.protocol + '//' + dolphinUrl.host;
          
          // Create DNS prefetch link for faster DNS resolution
          var dnsPrefetchLink = document.createElement('link');
          dnsPrefetchLink.rel = 'dns-prefetch';
          dnsPrefetchLink.href = preconnectUrl;
          document.head.appendChild(dnsPrefetchLink);
          
          // Create preconnect link element for full connection establishment
          var preconnectLink = document.createElement('link');
          preconnectLink.rel = 'preconnect';
          preconnectLink.href = preconnectUrl;
          preconnectLink.crossOrigin = 'anonymous';
          
          // Add to head to establish connection early
          document.head.appendChild(preconnectLink);
          
          if (LOGGING_ENABLED) {
            console.log('MoveoOne: DNS prefetch and preconnect established for prediction service:', preconnectUrl);
          }
        } catch (error) {
          if (LOGGING_ENABLED) {
            console.warn('MoveoOne: Failed to establish preconnect:', error);
          }
        }
    };

    // Warm up the prediction service with a lightweight request (ZERO performance impact)
    MoveoOneWeb.prototype.warmupPredictionService = function() {
        var self = this;
        // Only warmup if we have a session ID (after initialization)
        if (!this.sessionId) {
          // Retry after a short delay when session is ready
          setTimeout(function() { 
              self.warmupPredictionService(); 
          }, 100);
          return;
        }

        try {
          // Use the confirmed health endpoint
          var healthEndpoint = DOLPHIN_URL + '/health';
          
          // Record timing for performance monitoring
          var warmupStartTime = performance.now();
          
          // Use requestIdleCallback for zero performance impact (fallback to setTimeout)
          var scheduleWarmup = function(asyncCallback) {
            if (window.requestIdleCallback) {
              window.requestIdleCallback(asyncCallback, { timeout: 1000 });
            } else {
              setTimeout(asyncCallback, 0);
            }
          };

          scheduleWarmup(function() {
            try {
              // ES5 compatible fetch with Promise
              fetch(healthEndpoint, {
                method: 'GET', // Use GET instead of HEAD for better connection establishment
                headers: {
                  'Authorization': self.token
                },
                fetchpriority: 'low', // Low priority to not interfere with other requests
                keepalive: true, // Keep connection alive for reuse
                signal: AbortSignal.timeout(2000) // 2 second timeout to prevent hanging
              }).then(function(response) {
                var warmupTime = performance.now() - warmupStartTime;
                if (LOGGING_ENABLED) {
                  console.log('MoveoOne: Warmup successful - ' + response.status + ' in ' + warmupTime.toFixed(1) + 'ms for ' + healthEndpoint);
                }
                
                // Mark warmup as completed for future predict requests
                self.warmupCompleted = true;
                self.warmupTime = warmupTime;
              }).catch(function(error) {
                var warmupTime = performance.now() - warmupStartTime;
                if (LOGGING_ENABLED) {
                  console.warn('MoveoOne: Warmup failed after ' + warmupTime.toFixed(1) + 'ms: ' + error.message);
                }
                
                // Mark warmup as failed but don't retry to avoid performance impact
                self.warmupCompleted = false;
              });
            } catch (error) {
              var warmupTime = performance.now() - warmupStartTime;
              if (LOGGING_ENABLED) {
                console.warn('MoveoOne: Warmup failed after ' + warmupTime.toFixed(1) + 'ms: ' + error.message);
              }
              
              // Mark warmup as failed but don't retry to avoid performance impact
              self.warmupCompleted = false;
            }
          });

          if (LOGGING_ENABLED) {
            console.log('MoveoOne: Prediction service warmup scheduled (zero performance impact)');
          }
        } catch (error) {
          // Silently fail - warmup is optional
          if (LOGGING_ENABLED) {
            console.warn('MoveoOne: Warmup scheduling failed:', error);
          }
        }
    };

    // Methods to update predefined meta fields (locale, test, softwareVersion)
    // Note: libVersion is protected and cannot be changed
    MoveoOneWeb.prototype.setLocale = function(locale) {
        this.meta.locale = locale;
        this.meta.libVersion = LIB_VERSION; // Ensure libVersion is always present
        this.queueOrSendUpdate("meta");
    };

    MoveoOneWeb.prototype.setTest = function(test) {
        this.meta.test = test;
        this.meta.libVersion = LIB_VERSION; // Ensure libVersion is always present
        this.queueOrSendUpdate("meta");
    };

    // Helper method to filter out null values from meta object
    MoveoOneWeb.prototype.filterNullMetaValues = function(meta) {
        var filtered = {};
        var keys = Object.keys(meta);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (meta[key] !== null && meta[key] !== undefined) {
            filtered[key] = meta[key];
          }
        }
        return filtered;
    };

    // Helper method to queue updates before session starts or send immediately
    MoveoOneWeb.prototype.queueOrSendUpdate = function(type) {
        if (this.started) {
          // Session already started, send update immediately
          if (type === "meta") {
            this.addUpdateMetadataEvent();
          } else if (type === "additional") {
            this.addUpdateAdditionalMetadataEvent();
          }
        } else {
          // Session not started yet, queue the update
          this.pendingUpdates.push(type);
        }
    };

    // Process all pending updates after session starts
    MoveoOneWeb.prototype.processPendingUpdates = function() {
        // ES5 compatible Set alternative - remove duplicates
        var uniqueUpdates = [];
        for (var i = 0; i < this.pendingUpdates.length; i++) {
          var update = this.pendingUpdates[i];
          if (uniqueUpdates.indexOf(update) === -1) {
            uniqueUpdates.push(update);
          }
        }
  
        for (var j = 0; j < uniqueUpdates.length; j++) {
          var type = uniqueUpdates[j];
          if (type === "meta") {
            this.addUpdateMetadataEvent();
          } else if (type === "additional") {
            this.addUpdateAdditionalMetadataEvent();
          }
        }
  
        this.pendingUpdates = []; // Clear the queue
    };

    // Process all pending impression events after session starts
    MoveoOneWeb.prototype.processPendingImpressions = function() {
        if (this.pendingImpressions && this.pendingImpressions.length > 0) {
          for (var i = 0; i < this.pendingImpressions.length; i++) {
            var impression = this.pendingImpressions[i];
            // Send with original timestamp
            this.sendAutoImpressionWithTimestamp(impression.el, impression.rect, impression.action, impression.timestamp);
          }
          this.pendingImpressions = [];
        }
    };

    // Process all pending immediate events after session starts
    MoveoOneWeb.prototype.processPendingImmediateEvents = function() {
        if (this.pendingImmediateEvents && this.pendingImmediateEvents.length > 0) {
          for (var i = 0; i < this.pendingImmediateEvents.length; i++) {
            var event = this.pendingImmediateEvents[i];
            // Send with original timestamp
            this.trackImmediateWithTimestamp(event.type, event.data, event.timestamp);
          }
          this.pendingImmediateEvents = [];
        }
    };

    // Send immediate event with specific timestamp
    MoveoOneWeb.prototype.trackImmediateWithTimestamp = function(type, data, timestamp) {
        // Update session activity
        this.updateSessionActivity();
  
        var event = {
          c: this.context,
          type: "track",
          t: timestamp, // Use original timestamp
          prop: {
            sg: data.semanticGroup || "global",
            eID: data.id,
            eA: data.action,
            eT: data.type,
            eV: data.value || "",
            sc: this.getCurrentPath(),
          },
          sId: this.sessionId,
        };
  
        // Send immediately using sendBeacon for reliability
        this.sendEventImmediate(event);
    };

    // Send impression event with specific timestamp
    MoveoOneWeb.prototype.sendAutoImpressionWithTimestamp = function(el, rect, action, timestamp) {
        // Determine the element value based on type
        var value = "";
  
        if (el.matches("img")) {
          value = el.alt || el.title || this.getFilenameFromUrl(el.currentSrc || el.src) || "image";
        } else if (el.matches("video")) {
          value = el.title || this.getFilenameFromUrl(el.currentSrc || el.src) || "video";
        } else if (el.matches("iframe")) {
          value = el.title || this.getFilenameFromUrl(el.src) || "embedded_content";
        } else if (el.matches("a")) {
          value = (el.innerText || el.textContent || "").trim() || el.href || "link";
        } else if (el.matches('button,input,[role="button"]')) {
          value = (el.innerText || el.value || el.getAttribute("aria-label") || "").trim() || "button";
        } else if (el.matches("h1,h2,h3")) {
          value = (el.innerText || el.textContent || "").trim() || "heading";
        } else {
          value = (el.innerText || el.textContent || "").trim() || "text";
        }
  
        // Create impression event with proper structure and original timestamp
        var data = {
          semanticGroup: this.getSemanticGroup(el),
          id: this.generateStableElementId(el),
          type: el.tagName.toLowerCase(),
          action: action,
          value: value,
        };

        // Create event with original timestamp
        var event = {
          c: this.context,
          type: "track",
          t: timestamp, // Use original timestamp
          prop: {
            sg: data.semanticGroup,
            eID: data.id,
            eA: data.action,
            eT: data.type,
            eV: data.value,
            sc: this.getCurrentPath(),
          },
          sId: this.sessionId,
        };
  
        this.buffer.push(event);
        this.flushOrRecord(false);
    };

    // Helper method to add update_metadata event to buffer
    MoveoOneWeb.prototype.addUpdateMetadataEvent = function() {
        // Ensure libVersion is always present in meta and filter out null values
        var protectedMeta = this.filterNullMetaValues({
          libVersion: LIB_VERSION,
        });
        // ES5 compatible object spread alternative
        for (var key in this.meta) {
          if (this.meta.hasOwnProperty(key)) {
            protectedMeta[key] = this.meta[key];
          }
        }

        var event = {
          c: this.context,
          type: "update_metadata",
          t: Date.now(),
          prop: {},
          meta: protectedMeta,
          additionalMeta: {}, // ES5 compatible object spread alternative
          sId: this.sessionId,
        };
        
        // ES5 compatible object spread alternative for additionalMeta
        for (var key in this.additionalMeta) {
          if (this.additionalMeta.hasOwnProperty(key)) {
            event.additionalMeta[key] = this.additionalMeta[key];
          }
        }
  
        this.buffer.push(event);
        this.flushOrRecord(false);
    };

    // Method to update additional metadata (flexible key-value)
    MoveoOneWeb.prototype.updateAdditionalMetadata = function(additionalData) {
        // ES5 compatible object spread alternative
        for (var key in additionalData) {
          if (additionalData.hasOwnProperty(key)) {
            this.additionalMeta[key] = additionalData[key];
          }
        }
  
        this.queueOrSendUpdate("additional");
    };

    // Helper method to add update_metadata event to buffer
    MoveoOneWeb.prototype.addUpdateAdditionalMetadataEvent = function() {
        // Ensure libVersion is always present in meta and filter out null values
        var protectedMeta = this.filterNullMetaValues({
          libVersion: LIB_VERSION,
        });
        // ES5 compatible object spread alternative
        for (var key in this.meta) {
          if (this.meta.hasOwnProperty(key)) {
            protectedMeta[key] = this.meta[key];
          }
        }

        var event = {
          c: this.context,
          type: "update_metadata",
          t: Date.now(),
          prop: {},
          meta: protectedMeta,
          additionalMeta: {}, // ES5 compatible object spread alternative
          sId: this.sessionId,
        };
        
        // ES5 compatible object spread alternative for additionalMeta
        for (var key in this.additionalMeta) {
          if (this.additionalMeta.hasOwnProperty(key)) {
            event.additionalMeta[key] = this.additionalMeta[key];
          }
        }
  
        this.buffer.push(event);
        this.flushOrRecord(false);
    };

    // Legacy method - now only updates additionalMeta
    MoveoOneWeb.prototype.updateMetadata = function(metadata) {
        this.updateAdditionalMetadata(metadata);
    };

    // Helper method
    MoveoOneWeb.prototype.flushOrRecord = function(force) {
        if (force === undefined) force = false;
        if (force || this.buffer.length >= this.maxThreshold) {
          this.flush();
        }
    };

    MoveoOneWeb.prototype.track = function(type, data) {
        // Update session activity on any tracking event
        this.updateSessionActivity();

        var event = {
          c: this.context,
          type: "track",
          t: Date.now(),
          prop: {
            sg: data.semanticGroup || "global",
            eID: data.id,
            eA: data.action,
            eT: data.type,
            eV: data.value || "",
            sc: this.getCurrentPath(),
          },
          sId: this.sessionId,
        };
  
        this.buffer.push(event);
  
        if (this.buffer.length >= this.maxThreshold) {
          if (this.started) {
            this.flush();
          } else {
            // Wait for session to start, increase threshold temporarily
            if (LOGGING_ENABLED) {
              console.warn("MoveoOne: Buffer threshold reached before session started, waiting...");
            }
          }
        }
    };

    // Helper method to extract filename from URL
    MoveoOneWeb.prototype.getFilenameFromUrl = function(url) {
        if (!url) return "";
        try {
          var pathname = new URL(url).pathname;
          var filename = pathname.split("/").pop();
          return filename || "";
        } catch (e) {
          // If URL parsing fails, try to extract filename directly
          var parts = url.split("/");
          return parts[parts.length - 1] || "";
        }
    };

    // Helper to clean URLs (remove query params for privacy)
    MoveoOneWeb.prototype.cleanUrl = function(url) {
        if (!url) return "";
        try {
          var urlObj = new URL(url);
          return urlObj.origin + urlObj.pathname;
        } catch (e) {
          return url;
        }
    };

    // Helper method to get stable text content from an element (shortened for ID generation)
    MoveoOneWeb.prototype.getElementText = function(element) {
        // Comprehensive null/undefined checks
        if (!element || typeof element !== "object") return "";
  
        // Ensure it's a DOM element
        if (!element.tagName || typeof element.tagName !== "string") return "";
  
        try {
          // For form elements, only get static attributes (not dynamic values)
          if (element.tagName === "INPUT") {
            return (element.type || "input").toString();
          }
          if (element.tagName === "SELECT") {
            return (element.name || "select").toString();
          }
          if (element.tagName === "TEXTAREA") {
            return "textarea";
          }
  
          // For images, get alt text (handle SVG images too)
          if (element.tagName === "IMG") {
            return (element.alt || element.title || "image").toString();
          }
  
          // For video and audio elements, get title, src, or fallback
          if (element.tagName === "VIDEO" || element.tagName === "AUDIO") {
            var title = element.title || element.getAttribute('title');
            var src = element.src || element.currentSrc;
            var poster = element.poster; // For video elements
            
            if (title) return title;
            if (poster) return "video_with_poster";
            if (src) return element.tagName.toLowerCase() + "_media";
            return element.tagName.toLowerCase();
          }
  
          // For buttons and interactive elements, get all text content including children
          var interactiveTags = ["BUTTON", "A", "LABEL", "SUMMARY"];
          if (interactiveTags.indexOf(element.tagName) !== -1) {
            var text = element.textContent || element.innerText || "";
            text = text.trim().replace(/\s+/g, " ");
            return text.length > 300 ? text.substring(0, 297) + "..." : text;
          }

          // For text container elements, get all text content including children
          var textContainerTags = ["P", "LI", "H1", "H2", "H3", "H4", "H5", "H6", "BLOCKQUOTE", "PRE", "DD", "DT", "TD", "TH"];
          if (textContainerTags.indexOf(element.tagName) !== -1) {
            var text = element.textContent || element.innerText || "";
            text = text.trim().replace(/\s+/g, " ");
            return text.length > 300 ? text.substring(0, 297) + "..." : text;
          }

          // For other elements, get direct text content (not including children)
          var text = "";

          // Safe iteration over childNodes
          if (element.childNodes && element.childNodes.length > 0) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child && child.nodeType === 3 && child.textContent) { // Node.TEXT_NODE = 3
                text += child.textContent;
              }
            }
          }

          // Clean and limit the text (for ID generation purposes)
          text = text.trim().replace(/\s+/g, " ");
          return text.length > 100 ? text.substring(0, 97) + "..." : text;
        } catch (error) {
          // Fallback for any unexpected errors
          if (LOGGING_ENABLED) {
            console.warn("MoveoOne: Error getting element text:", error);
          }
          return "";
        }
    };

    // Helper method to get full text content from an element (for event data)
    MoveoOneWeb.prototype.getElementFullText = function(element) {
        // Comprehensive null/undefined checks
        if (!element || typeof element !== "object") return "";
  
        // Ensure it's a DOM element
        if (!element.tagName || typeof element.tagName !== "string") return "";
  
        try {
          // For form elements, only get static attributes (not dynamic values)
          if (element.tagName === "INPUT") {
            return (element.type || "input").toString();
          }
          if (element.tagName === "SELECT") {
            return (element.name || "select").toString();
          }
          if (element.tagName === "TEXTAREA") {
            return "textarea";
          }
  
          // For images, get alt text (handle SVG images too)
          if (element.tagName === "IMG") {
            return (element.alt || element.title || "image").toString();
          }
  
          // For video and audio elements, get title, src, or fallback
          if (element.tagName === "VIDEO" || element.tagName === "AUDIO") {
            var title = element.title || element.getAttribute('title');
            var src = element.src || element.currentSrc;
            var poster = element.poster; // For video elements
            
            if (title) return title;
            if (poster) return "video_with_poster";
            if (src) return element.tagName.toLowerCase() + "_media";
            return element.tagName.toLowerCase();
          }
  
          // For buttons and interactive elements, get all text content including children
          var interactiveTags = ["BUTTON", "A", "LABEL", "SUMMARY"];
          if (interactiveTags.indexOf(element.tagName) !== -1) {
            var text = element.textContent || element.innerText || "";
            text = text.trim().replace(/\s+/g, " ");
            return text;
          }

          // For text container elements, get all text content including children
          var textContainerTags = ["P", "LI", "H1", "H2", "H3", "H4", "H5", "H6", "BLOCKQUOTE", "PRE", "DD", "DT", "TD", "TH"];
          if (textContainerTags.indexOf(element.tagName) !== -1) {
            var text = element.textContent || element.innerText || "";
            text = text.trim().replace(/\s+/g, " ");
            return text;
          }

          // For other elements, get direct text content (not including children)
          var text = "";

          // Safe iteration over childNodes
          if (element.childNodes && element.childNodes.length > 0) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child && child.nodeType === 3 && child.textContent) { // Node.TEXT_NODE = 3
                text += child.textContent;
              }
            }
          }

          // Clean the text but don't limit length (for event data)
          text = text.trim().replace(/\s+/g, " ");
          return text;
        } catch (error) {
          // Fallback for any unexpected errors
          if (LOGGING_ENABLED) {
            console.warn("MoveoOne: Error getting element full text:", error);
          }
          return "";
        }
    };

    // New method to detect semantic group for an element
    MoveoOneWeb.prototype.getSemanticGroup = function(element) {
        // For global events, return "global"
        if (!element || element === document || element === window) {
          return "global";
        }
  
        // Define semantic elements in priority order
        var otherSemanticElements = [
          "article",
          "aside",
          "nav",
          "header",
          "footer",
        ];
  
        // First, traverse up the DOM tree to find the closest section parent
        var currentElement = element;
        var sectionParent = null;
  
        while (currentElement && currentElement !== document.body) {
          var tagName = currentElement.tagName.toLowerCase();
  
          if (tagName === "section") {
            sectionParent = currentElement;
            break;
          }
  
          currentElement = currentElement.parentElement;
        }
  
        // If section found, use it as semantic parent
        if (sectionParent) {
          return this.getSemanticGroupName(sectionParent, false); // false = don't include element name
        }
  
        // Second priority: Look for div with ID (higher priority than semantic elements)
        currentElement = element;
        var divWithIdParent = null;
  
        while (currentElement && currentElement !== document.body) {
          var tagName = currentElement.tagName.toLowerCase();
  
          // Look for div with id
          if (tagName === "div" && currentElement.id && currentElement.id.trim()) {
            divWithIdParent = currentElement;
            break;
          }
  
          currentElement = currentElement.parentElement;
        }
  
        // If div with ID found, use it as semantic parent
        if (divWithIdParent) {
          return this.getSemanticGroupName(divWithIdParent, false); // false = don't include element name
        }
  
        // Third priority: Look for other semantic elements
        currentElement = element;
        var semanticParent = null;
  
        while (currentElement && currentElement !== document.body) {
          var tagName = currentElement.tagName.toLowerCase();
  
          if (otherSemanticElements.indexOf(tagName) !== -1) {
            semanticParent = currentElement;
            break;
          }
  
          currentElement = currentElement.parentElement;
        }
  
        // If still no semantic parent, return "global"
        if (!semanticParent) {
          return "global";
        }
  
        // For non-section semantic elements, include the element name
        return this.getSemanticGroupName(semanticParent, true); // true = include element name
    };

    // Helper method to get semantic group name with smart naming strategy
    MoveoOneWeb.prototype.getSemanticGroupName = function(element, includeElementName) {
        var tagName = element.tagName.toLowerCase();
  
        // Smart naming strategy: Priority 1 - Element ID
        if (element.id && element.id.trim()) {
          var cleanId = this.cleanSemanticGroupName(element.id);
          return includeElementName ? tagName + '_' + cleanId : cleanId;
        }
  
        // Priority 2 - Use CSS classes for all semantic elements (both section and non-section)
        if (element.className && element.className.trim()) {
          var classNames = element.className.split(" ").filter(function(cls) {
            return cls.trim();
          });
  
          // Filter out common utility classes and find meaningful ones
          var meaningfulClasses = classNames.filter(function(cls) {
            var lowerCls = cls.toLowerCase();
            // Skip common utility classes and Webflow classes
            return !lowerCls.match(/^(bg-|text-|p-|m-|w-|h-|flex|grid|block|inline|hidden|visible|opacity|border|rounded|shadow|transition|transform|hover|focus|active|disabled|container|row|col|btn|card|modal|nav|header|footer|sidebar|main|content|wrapper|section|article|aside|w-|w-embed|w-script|w-dyn-|w-tab-|w-form-|max-|min-|items-|justify-|self-|place-|gap-|space-|order-|col-span-|row-span-|aspect-|object-|overflow-|z-|relative|absolute|fixed|sticky|top-|right-|bottom-|left-|inset-)$/) &&
                   !lowerCls.includes("active") &&
                   !lowerCls.includes("hidden");
          });
  
          if (meaningfulClasses.length > 0) {
            // Take the first meaningful class
            var cleanClass = this.cleanSemanticGroupName(meaningfulClasses[0]);
            return includeElementName ? tagName + '_' + cleanClass : cleanClass;
          }
  
          // If no meaningful classes, try to use the first class that's not too generic
          var nonGenericClasses = classNames.filter(function(cls) {
            var lowerCls = cls.toLowerCase();
            return !lowerCls.match(/^(container|wrapper|content|section|main|header|footer|nav|sidebar|row|col|btn|card|modal|w-|w-embed|w-script|w-dyn-|w-tab-|w-form-)$/);
          });
  
          if (nonGenericClasses.length > 0) {
            var cleanClass = this.cleanSemanticGroupName(nonGenericClasses[0]);
            return includeElementName ? tagName + '_' + cleanClass : cleanClass;
          }
        }
  
        // Priority 3 - Element position index as fallback
        var parent = element.parentElement;
  
        if (parent) {
          var siblings = [];
          var children = parent.children;
          for (var i = 0; i < children.length; i++) {
            if (children[i].tagName.toLowerCase() === tagName) {
              siblings.push(children[i]);
            }
          }
  
          if (siblings.length > 1) {
            var index = siblings.indexOf(element) + 1;
            return includeElementName ? tagName + '_' + index : tagName + '_' + index;
          }
        }
  
        // Final fallback
        return includeElementName ? tagName + '_element' : tagName;
    };

    // Helper method to clean semantic group names
    MoveoOneWeb.prototype.cleanSemanticGroupName = function(name) {
        if (!name) return "global";
  
        // Remove common prefixes/suffixes and clean up
        var cleaned = name
          .replace(/^[_-]+/, "") // Remove leading underscores/dashes
          .replace(/[_-]+$/, "") // Remove trailing underscores/dashes
          .replace(/[_-]+/g, "_") // Replace multiple underscores/dashes with single underscore
          .replace(/[^a-zA-Z0-9_]/g, "_") // Replace non-alphanumeric chars with underscore
          .toLowerCase();
  
        // Limit length
        if (cleaned.length > 50) {
          cleaned = cleaned.substring(0, 50);
        }
  
        return cleaned || "global";
    };

    // Helper method to determine if an element should be tracked
    MoveoOneWeb.prototype.shouldTrackElement = function(element) {
        // Skip script, style, and other non-visible elements
        var skipTags = [
          "SCRIPT",
          "STYLE",
          "NOSCRIPT",
          "META",
          "LINK",
          "HEAD",
          "TITLE",
        ];
        if (skipTags.indexOf(element.tagName) !== -1) return false;

        // Define interactive elements
        var interactiveTags = [
          "BUTTON",
          "A",
          "INPUT",
          "SELECT",
          "TEXTAREA",
          "LABEL",
          "SUMMARY",
          "DETAILS",
          "VIDEO",
          "AUDIO",
          "IMG",
          "IFRAME"
        ];
        
        var interactiveRoles = [
          "button",
          "link",
          "tab",
          "menuitem",
          "checkbox",
          "radio",
          "switch"
        ];

        var isInteractive = interactiveTags.indexOf(element.tagName) !== -1 || 
                           (element.getAttribute && interactiveRoles.indexOf(element.getAttribute('role')) !== -1);

        // For interactive elements, be more lenient with visibility checks
        if (isInteractive) {
          // Skip if element is part of tracking infrastructure
          if (element.id && element.id.indexOf("moveo") !== -1) return false;
          if (element.className && element.className.indexOf("moveo") !== -1) return false;
          
          // For interactive elements, only check if they're not completely hidden by CSS
          var style = window.getComputedStyle(element);
          if (style.display === 'none' || style.visibility === 'hidden') {
            return false;
          }
          
          // ALWAYS track interactive elements regardless of text content or getBoundingClientRect
          // This ensures buttons like "OK", "Cancel", etc. are always tracked
          return true;
        }

        // For non-interactive elements, use strict visibility check
        var rect = element.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return false;

        // For non-interactive elements, check for meaningful content
        var text = this.getElementText(element);
        if (!text || text.length < 1) return false;

        // Skip if element is part of tracking infrastructure
        if (element.id && element.id.indexOf("moveo") !== -1) return false;
        if (element.className && element.className.indexOf("moveo") !== -1) return false;

        // Check if this is a small text element that should be excluded
        if (this.isSmallTextElement(element) && this.hasTextContainerParent(element)) {
          return false;
        }

        // Check if this is a text container element that should be excluded (nested in another text container)
        if (this.isTextContainerElement(element) && this.hasTextContainerParent(element)) {
          return false;
        }

        return true;
    };

    // Helper method to identify small text elements
    MoveoOneWeb.prototype.isSmallTextElement = function(element) {
        var smallTextTags = [
          "SPAN", "EM", "STRONG", "I", "B", "U", "S", "SMALL", "MARK", "DEL", "INS", "SUB", "SUP", "CODE", "KBD", "SAMP", "VAR", "CITE", "ABBR", "TIME", "DATA"
        ];
        return smallTextTags.indexOf(element.tagName) !== -1;
    };

    // Helper method to identify text container elements
    MoveoOneWeb.prototype.isTextContainerElement = function(element) {
        var textContainerTags = [
          "P", "LI", "H1", "H2", "H3", "H4", "H5", "H6", "BLOCKQUOTE", "PRE", "DD", "DT", "TD", "TH"
        ];
        return textContainerTags.indexOf(element.tagName) !== -1;
    };

    // Helper method to check if element has a text container parent
    MoveoOneWeb.prototype.hasTextContainerParent = function(element) {
        var textContainerTags = [
          "P", "LI", "H1", "H2", "H3", "H4", "H5", "H6", "BLOCKQUOTE", "PRE", "DD", "DT", "TD", "TH"
        ];
        
        var current = element.parentElement;
        while (current && current !== document.body) {
          // Check if current element is a text container
          if (textContainerTags.indexOf(current.tagName) !== -1) {
            // Verify it has meaningful text content
            var parentText = this.getElementText(current);
            if (parentText && parentText.trim().length > 0) {
              return true;
            }
          }
          
          current = current.parentElement;
        }
        
        return false;
    };

    // Generate stable element ID
    MoveoOneWeb.prototype.generateStableElementId = function(element) {
        var text = this.getElementText(element);
        var semanticGroup = this.getSemanticGroup(element);
        var elementType = element.tagName.toLowerCase();
        
        // Create a stable hash-like ID
        var id = semanticGroup + '_' + elementType + '_' + text.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);
        return id;
    };

    // Generate global event ID
    MoveoOneWeb.prototype.generateGlobalEventId = function(eventType, data) {
        var id = 'global_' + eventType;
        if (data && data.path) {
            id += '_' + data.path.replace(/[^a-zA-Z0-9]/g, '_');
        }
        return id;
    };

    // Enhanced hover tracking for all elements with text
    MoveoOneWeb.prototype.setupHoverTracking = function() {
        var self = this;
        var hoverTimeout;
        var HOVER_DELAY = 1500; // Track hovers that last at least 1.5 seconds
  
        document.addEventListener("mouseover", function(event) {
          var target = event.target;
  
          // Clear any existing hover timeout
          clearTimeout(hoverTimeout);
  
          // Check if we should track this element
          if (!self.shouldTrackElement(target)) return;
  
          // Set timeout to track sustained hover
          hoverTimeout = setTimeout(function() {
            var elementText = self.getElementFullText(target);
  
            var data = {
              semanticGroup: self.getSemanticGroup(target),
              id: self.generateStableElementId(target),
              type: target.tagName.toLowerCase(),
              action: "hover",
              value: elementText,
            };
  
            self.track("hover", data);
          }, HOVER_DELAY);
        });
  
        // Clear timeout when mouse leaves
        document.addEventListener("mouseout", function(event) {
          clearTimeout(hoverTimeout);
        });
    };

    // Track page navigation
    MoveoOneWeb.prototype.trackPageNavigation = function() {
        var self = this;
        // Track page view for the new page - send immediately to ensure proper ordering
        var event = {
          c: this.context,
          type: "track",
          t: Date.now(),
          prop: {
            sg: "global",
            eID: this.generateGlobalEventId("page_view", {
              path: this.getCurrentPath(),
            }),
            eA: "page_view",
            eT: "page",
            eV: this.getCurrentPath() || "",
            sc: this.getCurrentPath() || "unknown",
          },
          sId: this.sessionId,
        };
  
        // Send page view immediately to ensure it's processed before any user interactions
        this.sendEventImmediate(event);
    };

    // Helper method to check if a URL is outbound
    MoveoOneWeb.prototype.isOutboundLink = function(url) {
        try {
          var link = new URL(url, window.location.href);
          var currentDomain = window.location.hostname;
  
          // Check if it's a different domain
          return link.hostname !== currentDomain && link.protocol.indexOf("http") === 0;
        } catch (e) {
          return false;
        }
    };

    // Updated method name and functionality
    MoveoOneWeb.prototype.setupDownloadOrOutboundLinkTracking = function() {
        var self = this;
        // Function to track existing download and outbound links
        var trackLinks = function() {
          var links = document.querySelectorAll("a[href]");
  
          for (var i = 0; i < links.length; i++) {
            var link = links[i];
            // Skip if already tracked
            if (self.hasInArray(self.trackedLinks, link)) continue;
  
            var url = link.href;
  
            // Check if it's a downloadable file
            var isDownloadable = url.match(/\.(pdf|zip|docx?|xlsx?|pptx?|txt|csv|json|xml|gz|tar|rar|7z|exe|dmg|pkg|deb|rpm|iso|img|mp3|mp4|avi|mov|wmv|flv|webm|ogg|wav|flac)$/i);
  
            // Check if it's an outbound link
            var isOutbound = self.isOutboundLink(url);
  
            // Only track if it's either downloadable or outbound
            if (isDownloadable || isOutbound) {
              self.addToArray(self.trackedLinks, link);
  
              link.addEventListener("click", function(event) {
                if (isDownloadable) {
                  // Handle download tracking
                  var filename = url.split("/").pop() || url;
                  var fileExtension = filename.split(".").pop() || "unknown";
  
                  self.trackImmediate("download", {
                    semanticGroup: self.getSemanticGroup(link),
                    id: self.generateStableElementId(link),
                    type: "download",
                    action: "click",
                    value: filename,
                  });
  
                  if (LOGGING_ENABLED) {
                    console.log("MoveoOne: Download tracked -", filename);
                  }
                } else if (isOutbound) {
                  // Handle outbound link tracking with improved reliability
                  var domain = new URL(url).hostname;
  
                  // Track the outbound link immediately (don't prevent default behavior)
                  self.trackImmediate("outbound_link", {
                    semanticGroup: self.getSemanticGroup(link),
                    id: self.generateStableElementId(link),
                    type: "outbound_link",
                    action: "click",
                    value: url,
                  });
  
                  if (LOGGING_ENABLED) {
                    console.log("MoveoOne: Outbound link tracked -", domain);
                  }
                  
                  // Let the browser handle navigation naturally (new tab, same tab, etc.)
                  // The trackImmediate method uses keepalive to ensure the request completes
                }
              });
            }
          }
        };
  
        // Track links on initial load
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", trackLinks);
        } else {
          trackLinks();
        }
  
        // Watch for dynamically added links
        var setupLinkObserver = function() {
          var targetNode = document.body || document.documentElement;
          if (targetNode) {
            var observer = new MutationObserver(function() {
              trackLinks();
            });
  
            observer.observe(targetNode, {
              childList: true,
              subtree: true,
            });
          }
        };
  
        if (document.body) {
          setupLinkObserver();
        } else {
          document.addEventListener("DOMContentLoaded", setupLinkObserver);
        }
    };

    // Setup page unload tracking
    MoveoOneWeb.prototype.setupPageUnloadTracking = function() {
        var self = this;
        // Track when user leaves the page
        window.addEventListener("beforeunload", function() {
          // Send any remaining events immediately
          if (self.buffer.length > 0) {
            // Use optimized approach for reliable delivery during page unload
            var data = JSON.stringify({ events: self.buffer.slice() }); // ES5 compatible array copy
            fetch(API_URL, {
              method: "POST",
              headers: {
                Authorization: self.token,
                "Content-Type": "application/json",
              },
              body: data,
              keepalive: true, // Ensures request completes even if page unloads
              signal: AbortSignal.timeout(5000), // 5 second timeout
            }).catch(function(error) {
              if (LOGGING_ENABLED) {
                console.error("MoveoOne Unload Error:", error);
              }
            });
          }
  
          // Update session timestamp
          self.updateSessionActivity();
        });
  
        // Backup: Also listen for pagehide event (more reliable than beforeunload)
        window.addEventListener("pagehide", function() {
          // Send any remaining events immediately
          if (self.buffer.length > 0) {
            var data = JSON.stringify({ events: self.buffer.slice() }); // ES5 compatible array copy
            fetch(API_URL, {
              method: "POST",
              headers: {
                Authorization: self.token,
                "Content-Type": "application/json",
              },
              body: data,
              keepalive: true,
              signal: AbortSignal.timeout(5000),
            }).catch(function(error) {
              if (LOGGING_ENABLED) {
                console.error("MoveoOne PageHide Error:", error);
              }
            });
          }
  
          // Update session timestamp
          self.updateSessionActivity();
        });
  
        // Also track page visibility changes
        document.addEventListener("visibilitychange", function() {
          if (document.visibilityState === "hidden") {
            self.updateSessionActivity();
            // Flush any pending events when page becomes hidden
            if (self.buffer.length > 0) {
              self.flush();
            }
  
            // Track when user switches away from the page
            self.track("visibility_change", {
              semanticGroup: "global",
              id: self.generateGlobalEventId("visibility_change", {
                state: "hidden",
              }),
              type: "hidden",
              action: "visibility_change",
              value: "page_hidden",
            });
          } else if (document.visibilityState === "visible") {
            self.updateSessionActivity();
  
            // Track when user returns to the page
            self.track("visibility_change", {
              semanticGroup: "global",
              id: self.generateGlobalEventId("visibility_change", {
                state: "visible",
              }),
              type: "visible",
              action: "visibility_change",
              value: "page_visible",
            });
          }
        });
    };

    // Setup media tracking
    MoveoOneWeb.prototype.setupMediaTracking = function() {
        var self = this;
        // Track existing media elements
        var trackMediaElements = function() {
          var mediaElements = document.querySelectorAll("video, audio");
  
          for (var i = 0; i < mediaElements.length; i++) {
            var media = mediaElements[i];
            // Avoid duplicate listeners by checking if already tracked
            if (self.hasInArray(self.trackedMedia, media)) continue;
            self.addToArray(self.trackedMedia, media);
  
            var mediaType = media.tagName.toLowerCase();
            var mediaId = self.generateStableElementId(media);
  
            media.addEventListener("play", function() {
              self.track("media_play", {
                semanticGroup: self.getSemanticGroup(media),
                id: mediaId,
                type: mediaType,
                action: "media_play",
              });
            });
  
            media.addEventListener("pause", function() {
              self.track("media_pause", {
                semanticGroup: self.getSemanticGroup(media),
                id: mediaId,
                type: mediaType,
                action: "media_pause",
              });
            });
  
            media.addEventListener("ended", function() {
              self.track("media_complete", {
                semanticGroup: self.getSemanticGroup(media),
                id: mediaId,
                type: mediaType,
                action: "media_complete",
              });
            });
          }
        };
  
        // Track media elements on initial load
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", trackMediaElements);
        } else {
          trackMediaElements();
        }
  
        // Watch for dynamically added media elements
        // Only set up observer if document.body exists, otherwise wait for DOM ready
        var setupObserver = function() {
          var targetNode = document.body || document.documentElement;
          if (targetNode) {
            var observer = new MutationObserver(function() {
              trackMediaElements();
            });
  
            observer.observe(targetNode, {
              childList: true,
              subtree: true,
            });
          }
        };
  
        if (document.body) {
          setupObserver();
        } else {
          document.addEventListener("DOMContentLoaded", setupObserver);
        }
    };

    // Setup clipboard tracking
    MoveoOneWeb.prototype.setupClipboardTracking = function() {
        var self = this;
        document.addEventListener("copy", function(e) {
          var text = window.getSelection().toString();
  
          // Only track if there's actual text selected
          if (text && text.trim().length > 0) {
            // Get the semantic group from the selection's anchor node
            var selection = window.getSelection();
            var anchorElement = selection.anchorNode
              ? selection.anchorNode.nodeType === 1 // Node.ELEMENT_NODE = 1
                ? selection.anchorNode
                : selection.anchorNode.parentElement
              : null;
  
            self.track("copy", {
              semanticGroup: self.getSemanticGroup(anchorElement),
              id: anchorElement
                ? self.generateStableElementId(anchorElement)
                : "copy_text",
              type: "clipboard",
              action: "copy",
              value: text,
            });
          }
        });
    };

    // Flush method
    MoveoOneWeb.prototype.flush = function() {
        if (this.buffer.length === 0) return;
  
        var dataToSend = this.buffer.slice(); // ES5 compatible array copy
        this.buffer = [];
  
        // Debug logging
        if (LOGGING_ENABLED) {
          console.log("MoveoOne: Sending events", dataToSend);
          for (var i = 0; i < dataToSend.length; i++) {
            var event = dataToSend[i];
            console.log("Event " + i + ":", {
              type: event.type,
              context: event.c,
              sessionId: event.sId,
              eA: event.prop.eA,
              eT: event.prop.eT,
              eV: event.prop.eV,
              sc: event.prop.sc,
              meta: event.meta,
              additionalMeta: event.additionalMeta,
            });
          }
        }
  
        fetch(API_URL, {
          method: "POST",
          headers: {
            Authorization: this.token,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ events: dataToSend }),
        }).catch(function(error) {
          if (LOGGING_ENABLED) {
            console.error("MoveoOne Error:", error);
          }
        });
    };

    // Send single event immediately using optimized approach for page unload scenarios
    MoveoOneWeb.prototype.sendEventImmediate = function(event) {
        var data = JSON.stringify({ events: [event] });
  
        // For outbound links and page unloads, we need maximum reliability
        // Use fetch with keepalive and additional optimizations
        fetch(API_URL, {
          method: "POST",
          headers: {
            Authorization: this.token,
            "Content-Type": "application/json",
          },
          body: data,
          keepalive: true, // Ensures request completes even if page unloads
          // Additional options for better reliability
          signal: AbortSignal.timeout(3000), // 3 second timeout for faster response
        }).catch(function(error) {
          if (LOGGING_ENABLED) {
            console.error("MoveoOne Immediate Error:", error);
          }
        });
    };

    // Enrich with IP address
    MoveoOneWeb.prototype.enrichWithIpAddress = function() {
        var self = this;
        return fetch("https://api.moveo.one/api/my-ip")
          .then(function(response) { return response.json(); })
          .then(function(data) {
            // IP address from your own endpoint
            return {
              ipAddress: data.ip || "Unknown",
            };
          })
          .catch(function(err) {
            if (LOGGING_ENABLED) {
              console.warn("MoveoOne: Failed to get IP address", err);
            }
            return { ipAddress: "Unknown" };
          });
    };

    // Immediate track method for critical events (like downloads and outbound links)
    MoveoOneWeb.prototype.trackImmediate = function(type, data) {
        // Check if session is ready, if not queue the event
        if (!this.started) {
          // Queue immediate events until session is ready
          this.pendingImmediateEvents.push({
            type: type,
            data: data,
            timestamp: Date.now(),
          });
          return;
        }
  
        // Update session activity
        this.updateSessionActivity();
  
        var event = {
          c: this.context,
          type: "track",
          t: Date.now(),
          prop: {
            sg: data.semanticGroup || "global",
            eID: data.id,
            eA: data.action,
            eT: data.type,
            eV: data.value || "",
            sc: this.getCurrentPath(),
          },
          sId: this.sessionId,
        };
  
        // Merge any event-specific metadata into additionalMeta
        if (data.metadata) {
          event.additionalMeta = {};
          // ES5 compatible object spread alternative
          for (var key in data.metadata) {
            if (data.metadata.hasOwnProperty(key)) {
              event.additionalMeta[key] = data.metadata[key];
            }
          }
        }
  
        // Send immediately using sendBeacon for reliability
        this.sendEventImmediate(event);
    };

    // Enhanced click tracking for all elements with text
    MoveoOneWeb.prototype.setupClickTracking = function() {
        var self = this;
        // Function to handle click events
        var handleClick = function(event) {
          var target = event.target;
  
          // Find the closest interactive element if we clicked on a child
          var findInteractiveParent = function(element) {
            var interactiveTags = ["BUTTON", "A", "INPUT", "SELECT", "TEXTAREA", "LABEL", "SUMMARY", "VIDEO", "AUDIO", "IMG", "IFRAME"];
            var interactiveRoles = ["button", "link", "tab", "menuitem", "checkbox", "radio", "switch"];
            
            var current = element;
            while (current && current !== document.body) {
              if (interactiveTags.indexOf(current.tagName) !== -1 || 
                  (current.getAttribute && interactiveRoles.indexOf(current.getAttribute('role')) !== -1)) {
                return current;
              }
              current = current.parentElement;
            }
            return element; // Return original if no interactive parent found
          };
  
          // Try to find the actual interactive element that was clicked
          var interactiveElement = findInteractiveParent(target);
          
          // Check if we should track this element
          if (!self.shouldTrackElement(interactiveElement)) {
            // Debug logging for untracked elements
            if (LOGGING_ENABLED) {
              console.log("MoveoOne: Element not tracked:", {
                tagName: interactiveElement.tagName,
                id: interactiveElement.id,
                className: interactiveElement.className,
                text: interactiveElement.textContent ? interactiveElement.textContent.trim() : '',
                visible: interactiveElement.getBoundingClientRect().width > 0 && interactiveElement.getBoundingClientRect().height > 0
              });
            }
            return;
          }
  
          // Skip download and outbound links as they're handled separately by setupDownloadOrOutboundLinkTracking
          if (interactiveElement.tagName === "A" && interactiveElement.href) {
            var isDownloadable = interactiveElement.href.match(/\.(pdf|zip|docx?|xlsx?|pptx?|txt|csv|json|xml|gz|tar|rar|7z|exe|dmg|pkg|deb|rpm|iso|img|mp3|mp4|avi|mov|wmv|flv|webm|ogg|wav|flac)$/i);
            var isOutbound = self.isOutboundLink(interactiveElement.href);
  
            if (isDownloadable || isOutbound) {
              return;
            }
          }
  
          // Get the text content of the clicked element
          var elementText = self.getElementFullText(interactiveElement);
  
          var data = {
            semanticGroup: self.getSemanticGroup(interactiveElement),
            id: self.generateStableElementId(interactiveElement),
            type: interactiveElement.tagName.toLowerCase(),
            action: "click",
            value: elementText,
          };
  
          // Use immediate tracking for internal navigation links to prevent race conditions
          if (interactiveElement.tagName === "A" && interactiveElement.href) {
            try {
              var linkUrl = new URL(interactiveElement.href, window.location.href);
              var currentUrl = new URL(window.location.href);
  
              // Only handle internal navigation (same domain, different path)
              // Outbound links are handled by setupDownloadOrOutboundLinkTracking
              if (linkUrl.hostname === currentUrl.hostname && linkUrl.pathname !== currentUrl.pathname) {
                self.trackImmediate("click", data);
                return;
              }
            } catch (e) {
              // If URL parsing fails, log the error and fall back to buffered tracking
              if (LOGGING_ENABLED) {
                console.warn("MoveoOne: Failed to parse URL for click tracking:", e);
              }
            }
          }
  
          // Use buffered tracking for non-navigation clicks
          self.track("click", data);
          
          // Debug logging for tracked clicks
          if (LOGGING_ENABLED) {
            console.log("MoveoOne: Click tracked:", {
              tagName: interactiveElement.tagName,
              id: interactiveElement.id,
              text: elementText,
              semanticGroup: data.semanticGroup
            });
          }
        };
  
        // Add click listener to document
        document.addEventListener("click", handleClick);
  
        // Also watch for dynamically added elements
        var observer = new MutationObserver(function(mutations) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            for (var j = 0; j < mutation.addedNodes.length; j++) {
              var node = mutation.addedNodes[j];
              if (node.nodeType === 1) { // Node.ELEMENT_NODE = 1
                // Re-attach click listener to ensure new elements are tracked
                if (node.addEventListener) {
                  node.addEventListener("click", handleClick);
                }
                // Also check child elements
                if (node.querySelectorAll) {
                  var children = node.querySelectorAll("*");
                  for (var k = 0; k < children.length; k++) {
                    var child = children[k];
                    if (child.addEventListener) {
                      child.addEventListener("click", handleClick);
                    }
                  }
                }
              }
            }
          }
        });
  
        // Start observing
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
    };

    // Setup scroll tracking
    MoveoOneWeb.prototype.setupScrollTracking = function() {
        var self = this;
        var lastScrollPosition = 0;
        var scrollTimeout;
  
        window.addEventListener("scroll", function() {
          clearTimeout(scrollTimeout);
  
          scrollTimeout = setTimeout(function() {
            var scrollPosition = window.scrollY;
            var documentHeight = document.documentElement.scrollHeight - window.innerHeight;
            var scrollPercentage = Math.round((scrollPosition / documentHeight) * 100);
  
            if (Math.abs(scrollPosition - lastScrollPosition) > 100) {
              self.track("scroll", {
                semanticGroup: "global",
                id: self.generateGlobalEventId("scroll", {
                  scrollPercentage: scrollPercentage,
                }),
                type: "scroll",
                action: "scroll",
                value: scrollPercentage.toString(),
              });
  
              lastScrollPosition = scrollPosition;
            }
          }, 500);
        });
    };

    // Setup form tracking
    MoveoOneWeb.prototype.setupFormTracking = function() {
        var self = this;
        document.addEventListener("submit", function(event) {
          var form = event.target;
  
          // Use immediate tracking for form submissions to prevent race conditions
          self.trackImmediate("form_submit", {
            semanticGroup: self.getSemanticGroup(form),
            id: self.generateStableElementId(form),
            type: "form",
            action: "form_submit",
            value: "",
          });
        });
  
        document.addEventListener("change", function(event) {
          var target = event.target;
          var formTags = ["select", "input", "textarea"];
          if (formTags.indexOf(target.tagName.toLowerCase()) !== -1) {
            self.track("form_change", {
              semanticGroup: self.getSemanticGroup(target),
              id: self.generateStableElementId(target),
              type: target.type || target.tagName.toLowerCase(),
              action: "form_change",
              value: target.type === "password" ? "[REDACTED]" : target.value,
            });
          }
        });
    };

    // Setup resize tracking
    MoveoOneWeb.prototype.setupResizeTracking = function() {
        var self = this;
        var resizeTimeout;
  
        window.addEventListener("resize", function() {
          clearTimeout(resizeTimeout);
  
          resizeTimeout = setTimeout(function() {
            var newViewport = {
              width: window.innerWidth,
              height: window.innerHeight,
            };
  
            // Only track if there's a significant change
            if (Math.abs(newViewport.width - self.currentViewport.width) > 50 ||
                Math.abs(newViewport.height - self.currentViewport.height) > 50) {
              self.track("viewport_resize", {
                semanticGroup: "global",
                id: self.generateGlobalEventId("viewport_resize", {
                  width: newViewport.width,
                  height: newViewport.height,
                }),
                type: "resize",
                action: "viewport_resize",
                value: newViewport.width + 'x' + newViewport.height,
              });
  
              self.currentViewport = newViewport;
            }
          }, 300);
        });
    };

    // Setup resize tracking
    MoveoOneWeb.prototype.setupResizeTracking = function() {
        var self = this;
        var resizeTimeout;
  
        window.addEventListener("resize", function() {
          clearTimeout(resizeTimeout);
  
          resizeTimeout = setTimeout(function() {
            var newViewport = {
              width: window.innerWidth,
              height: window.innerHeight,
            };
  
            // Only track if there's a significant change
            if (Math.abs(newViewport.width - self.currentViewport.width) > 50 ||
                Math.abs(newViewport.height - self.currentViewport.height) > 50) {
              self.track("viewport_resize", {
                semanticGroup: "global",
                id: self.generateGlobalEventId("viewport_resize", {
                  width: newViewport.width,
                  height: newViewport.height,
                }),
                type: "resize",
                action: "viewport_resize",
                value: newViewport.width + 'x' + newViewport.height,
              });
  
              self.currentViewport = newViewport;
            }
          }, 300);
        });
    };

    // Start method - ES5 compatible async/await conversion
    MoveoOneWeb.prototype.start = function() {
        var self = this;
        // Prevent multiple start() calls
        if (this.started) {
          if (LOGGING_ENABLED) {
            console.warn("MoveoOne: Session already started, ignoring duplicate start() call");
          }
          return Promise.resolve();
        }
        
        // If this is a page navigation, send page_navigation event instead of start_session
        if (this.isPageNavigation) {
          this.trackPageNavigation();
          this.started = true;
          
          // Optionally warm up the prediction service (lightweight request with zero performance impact)
          this.warmupPredictionService();
          
          this.processPendingUpdates();
          this.processPendingImpressions(); // Process any pending impressions
          this.processPendingImmediateEvents(); // Process any pending immediate events
  
          // Force flush any oversized buffer that was waiting
          if (this.buffer.length >= this.maxThreshold) {
            this.flush();
          }
          return Promise.resolve();
        }
  
        // If this is an existing session (session ID was reused), don't send start_session
        if (this.isExistingSession) {
          this.started = true;
          
          // Optionally warm up the prediction service (lightweight request with zero performance impact)
          this.warmupPredictionService();
          
          this.processPendingUpdates();
          this.processPendingImpressions(); // Process any pending impressions
          this.processPendingImmediateEvents(); // Process any pending immediate events
  
          // Force flush any oversized buffer that was waiting
          if (this.buffer.length >= this.maxThreshold) {
            this.flush();
          }
  
          // Track initial page view for the return visit
          this.track("page_view", {
            semanticGroup: "global",
            id: this.generateGlobalEventId("page_view", {
              path: this.getCurrentPath(),
            }),
            type: "page",
            action: "page_view",
            value: this.getCurrentPath(),
          });
  
          this.track("viewport_size", {
            semanticGroup: "global",
            id: this.generateGlobalEventId("viewport_size", {
              path: this.getCurrentPath(),
            }),
            type: "viewport",
            action: "viewport_size",
            value: this.currentViewport.width + 'x' + this.currentViewport.height,
          });
  
          return Promise.resolve();
        }
  
        // This is a genuinely new session
        // Ensure libVersion is always present in meta and filter out null values
        var protectedMeta = this.filterNullMetaValues({
          libVersion: LIB_VERSION,
        });
        // ES5 compatible object spread alternative
        for (var key in this.meta) {
          if (this.meta.hasOwnProperty(key)) {
            protectedMeta[key] = this.meta[key];
          }
        }

        var event = {
          c: this.context,
          type: "start_session",
          t: Date.now(),
          prop: {},
          meta: protectedMeta,
          additionalMeta: {}, // ES5 compatible object spread alternative
          sId: this.sessionId,
        };
        
        // ES5 compatible object spread alternative for additionalMeta
        for (var key in this.additionalMeta) {
          if (this.additionalMeta.hasOwnProperty(key)) {
            event.additionalMeta[key] = this.additionalMeta[key];
          }
        }
  
        // Extract UTM parameters
        var params = new URLSearchParams(window.location.search);
        var utmParams = {
          utm_source: params.get("utm_source") || "",
          utm_medium: params.get("utm_medium") || "",
          utm_campaign: params.get("utm_campaign") || "",
          utm_term: params.get("utm_term") || "",
          utm_content: params.get("utm_content") || "",
        };
  
        // Check returning visitor status and add to additionalMeta
        var isReturning = localStorage.getItem("moveo-returning") === "true";
  
        if (!isReturning) {
          localStorage.setItem("moveo-returning", "true");
        }
  
        // All session data goes to additionalMeta
        var sessionData = {
          userAgent: navigator.userAgent || "Unknown",
          platform: this.getPlatformInfo(),
          language: this.getLanguageInfo(),
          timezone: this.getTimezoneInfo(),
          referrer: document.referrer || "Direct",
          returningVisitor: isReturning,
        };
  
        // Screen and viewport information
        var screenData = {
          screenWidth: window.screen.width,
          screenHeight: window.screen.height,
          screenColorDepth: window.screen.colorDepth,
          devicePixelRatio: window.devicePixelRatio || 1,
        };
  
        // Get IP address data asynchronously (this is the slow part)
        return this.enrichWithIpAddress().then(function(ipData) {
          // Add all additional data to additionalMeta
          for (var key in utmParams) {
            if (utmParams.hasOwnProperty(key)) {
              event.additionalMeta[key] = utmParams[key];
            }
          }
          for (var key in sessionData) {
            if (sessionData.hasOwnProperty(key)) {
              event.additionalMeta[key] = sessionData[key];
            }
          }
          for (var key in screenData) {
            if (screenData.hasOwnProperty(key)) {
              event.additionalMeta[key] = screenData[key];
            }
          }
          for (var key in ipData) {
            if (ipData.hasOwnProperty(key)) {
              event.additionalMeta[key] = ipData[key];
            }
          }
          event.additionalMeta.title = document.title;
  
          // Update instance additionalMeta
          for (var key in event.additionalMeta) {
            if (event.additionalMeta.hasOwnProperty(key)) {
              self.additionalMeta[key] = event.additionalMeta[key];
            }
          }
  
          self.buffer.push(event);
          self.started = true; // Set started to true after adding start_session event
  
          // Optionally warm up the prediction service (lightweight request with zero performance impact)
          self.warmupPredictionService();
  
          // Process any pending updates that were queued before session started
          self.processPendingUpdates();
          self.processPendingImpressions(); // Process any pending impressions
          self.processPendingImmediateEvents(); // Process any pending immediate events
  
          // Force flush any oversized buffer that was waiting
          if (self.buffer.length >= self.maxThreshold) {
            self.flush();
          }
  
          // Flush the start_session event first
          self.flush();
  
          // Track initial page view
          self.track("page_view", {
            semanticGroup: "global",
            id: self.generateGlobalEventId("page_view", {
              path: self.getCurrentPath(),
            }),
            type: "page",
            action: "page_view",
            value: document.title,
          });
  
          self.track("viewport_size", {
            semanticGroup: "global",
            id: self.generateGlobalEventId("viewport_size", {
              path: self.getCurrentPath(),
            }),
            type: "viewport",
            action: "viewport_size",
            value: self.currentViewport.width + 'x' + self.currentViewport.height,
          });
        });
    };

    // Initialize impression observer
    MoveoOneWeb.prototype.initImpressionObserver = function() {
        var self = this;
        // Remove early exit to allow impression tracking to start immediately
        // if (!this.started) return; // Removed this line
  
        // Configuration
        var IO_THRESHOLD = 0.2; // 20% visible
        var APPEAR_DELAY = 800; // ms delay for appear events
  
        // Track pending appear events with timeouts
        var pendingAppearEvents = {}; // ES5 compatible Map alternative: element -> timeout ID
  
        // Internals
        var schedule = (function() {
          var id;
          return function(fn) {
            cancelAnimationFrame(id);
            id = requestAnimationFrame(fn);
          };
        })();
  
        // Create intersection observer for appear/disappear events
        this.impressionObserver = new IntersectionObserver(
          function(entries) {
            schedule(function() {
              for (var i = 0; i < entries.length; i++) {
                var e = entries[i];
                if (e.isIntersecting && !self.hasInArray(self.seenElements, e.target)) {
                  // Element entered viewport - start timer for appear event
                  var timeoutId = setTimeout(function() {
                    // Check if element is still visible after delay
                    if (self.hasInArray(self.seenElements, e.target)) {
                      self.sendAutoImpression(
                        e.target,
                        e.boundingClientRect,
                        "appear"
                      );
                      // Mark as actually appeared (after sending appear event)
                      self.addToArray(self.appearedElements, e.target);
                    }
                    // Clean up the pending event
                    delete pendingAppearEvents[e.target];
                  }, APPEAR_DELAY);
  
                  // Store the timeout and mark as seen (currently in viewport)
                  pendingAppearEvents[e.target] = timeoutId;
                  self.addToArray(self.seenElements, e.target);
                } else if (!e.isIntersecting && self.hasInArray(self.seenElements, e.target)) {
                  // Element left viewport
  
                  // Cancel pending appear event if it exists
                  var pendingTimeout = pendingAppearEvents[e.target];
                  if (pendingTimeout) {
                    clearTimeout(pendingTimeout);
                    delete pendingAppearEvents[e.target];
                  } else if (self.hasInArray(self.appearedElements, e.target)) {
                    // Element was visible long enough to have triggered appear event
                    // AND has actually appeared - so now send disappear event
                    self.sendAutoImpression(
                      e.target,
                      e.boundingClientRect,
                      "disappear"
                    );
                    // Remove from appeared elements since it's now disappeared
                    self.removeFromArray(self.appearedElements, e.target);
                  }
  
                  // Remove from seen elements (no longer in viewport)
                  self.removeFromArray(self.seenElements, e.target);
                }
              }
            });
          },
          { root: null, threshold: IO_THRESHOLD }
        );
  
        // Discovery helper
        var addIfInteresting = function(el) {
          if (!el || el.nodeType !== 1) return; // Only element nodes
  
          // Skip elements that are already being observed
          if (self.hasInArray(self.trackedElements, el)) return;
  
          // Use the same shouldTrackElement logic for consistency with click/hover tracking
          if (self.shouldTrackElement(el)) {
            self.impressionObserver.observe(el);
            self.addToArray(self.trackedElements, el);
          }
        };
  
        // Initial DOM sweep - wait for DOM to be ready
        var performInitialScan = function() {
          var elements = document.querySelectorAll("*");
          for (var i = 0; i < elements.length; i++) {
            addIfInteresting(elements[i]);
          }
  
          // Handle elements that are already visible when observer starts
          setTimeout(function() {
            var visibleElements = document.querySelectorAll("*");
            for (var j = 0; j < visibleElements.length; j++) {
              var el = visibleElements[j];
              if (self.hasInArray(self.trackedElements, el)) {
                var rect = el.getBoundingClientRect();
                var isVisible =
                  rect.top < window.innerHeight &&
                  rect.bottom > 0 &&
                  rect.width > 0 &&
                  rect.height > 0;
  
                if (isVisible && !self.hasInArray(self.seenElements, el)) {
                  // Element is already visible - send appear event immediately
                  self.addToArray(self.seenElements, el);
                  self.sendAutoImpression(el, rect, "appear");
                  // Mark as actually appeared
                  self.addToArray(self.appearedElements, el);
                }
              }
            }
          }, 100); // Small delay to ensure observer is fully set up
        };
  
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", performInitialScan);
        } else {
          performInitialScan();
        }
  
        // SPA / lazy-load support: watch for new nodes
        var mutationObserver = new MutationObserver(function(mutations) {
          for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            for (var j = 0; j < mutation.addedNodes.length; j++) {
              var node = mutation.addedNodes[j];
              if (node.nodeType !== 1) continue;
              addIfInteresting(node);
              if (node.querySelectorAll) {
                var children = node.querySelectorAll("*");
                for (var k = 0; k < children.length; k++) {
                  addIfInteresting(children[k]);
                }
              }
            }
          }
        });
  
        mutationObserver.observe(document.documentElement, {
          childList: true,
          subtree: true,
        });
  
        // Clean up timeouts when page unloads to prevent memory leaks
        window.addEventListener("beforeunload", function() {
          for (var element in pendingAppearEvents) {
            if (pendingAppearEvents.hasOwnProperty(element)) {
              clearTimeout(pendingAppearEvents[element]);
            }
          }
          // Clear the object
          for (var key in pendingAppearEvents) {
            delete pendingAppearEvents[key];
          }
        });
    };

    // Send auto impression
    MoveoOneWeb.prototype.sendAutoImpression = function(el, rect, action) {
        // Check if session is ready, if not queue the impression
        if (!this.started) {
          // Queue impression events until session is ready
          this.pendingImpressions.push({
            el: el,
            rect: rect,
            action: action,
            timestamp: Date.now(),
          });
          return;
        }
  
        // Determine the element value based on type
        var value = "";
  
        if (el.matches("img")) {
          // For images, use alt text, title, or fallback to src filename
          value = el.alt || el.title || this.getFilenameFromUrl(el.currentSrc || el.src) || "image";
        } else if (el.matches("video")) {
          // For videos, use title or fallback to src filename
          value = el.title || this.getFilenameFromUrl(el.currentSrc || el.src) || "video";
        } else if (el.matches("iframe")) {
          // For iframes (YouTube, Vimeo), use title or extract from src
          value = el.title || this.getFilenameFromUrl(el.src) || "embedded_content";
        } else if (el.matches("a")) {
          // For links, use the link text or href if no text
          value = (el.innerText || el.textContent || "").trim() || el.href || "link";
        } else if (el.matches('button,input,[role="button"]')) {
          // For buttons, use text content, value, or aria-label
          value = (el.innerText || el.value || el.getAttribute("aria-label") || "").trim() || "button";
        } else if (el.matches("h1,h2,h3")) {
          // For headings, use the text content
          value = (el.innerText || el.textContent || "").trim() || "heading";
        } else if (el.matches("input:not([type=button]):not([type=submit])")) {
          // For form inputs, use type or placeholder
          value = el.placeholder || el.type || "input";
        } else if (el.matches("select")) {
          // For select dropdowns, use name or selected option
          var selectedOption = el.options[el.selectedIndex];
          value = selectedOption ? selectedOption.text : (el.name || "select");
        } else if (el.matches("textarea")) {
          // For textareas, use placeholder or name
          value = el.placeholder || el.name || "textarea";
        } else if (el.matches("label")) {
          // For labels, use text content or for attribute
          value = (el.innerText || el.textContent || "").trim() || el.getAttribute('for') || "label";
        } else if (el.matches("summary")) {
          // For summary elements, use text content
          value = (el.innerText || el.textContent || "").trim() || "summary";
        } else if (el.matches("details")) {
          // For details elements, use text content
          value = (el.innerText || el.textContent || "").trim() || "details";
        } else if (el.matches("audio")) {
          // For audio elements, use title or src
          value = el.title || this.getFilenameFromUrl(el.src) || "audio";
        } else if (el.matches('[role="checkbox"], [role="radio"], [role="switch"]')) {
          // For form controls with roles, use aria-label or text content
          value = el.getAttribute('aria-label') || (el.innerText || el.textContent || "").trim() || el.getAttribute('role');
        } else if (el.matches('[role="tab"], [role="menuitem"], [role="link"]')) {
          // For navigation elements with roles, use text content or aria-label
          value = (el.innerText || el.textContent || "").trim() || el.getAttribute('aria-label') || el.getAttribute('role');
        } else {
          // For text elements, use the text content
          value = (el.innerText || el.textContent || "").trim() || "text";
        }
  
        // Don't limit value length for event data - pass full content
  
        // Create impression event with proper structure
        var data = {
          semanticGroup: this.getSemanticGroup(el),
          id: this.generateStableElementId(el),
          type: el.tagName.toLowerCase(), // HTML tag name as type
          action: action, // 'appear' or 'disappear'
          value: value, // The actual content (text/alt/href)
        };
  
        this.track("impression", data);
    };

    // Global initialization function
    window.MoveoOne = {
      init: function (token, options) {
        // Prevent multiple initializations
        if (window.MoveoOne.instance) {
          if (LOGGING_ENABLED) {
            console.warn("MoveoOne: Already initialized, returning existing instance");
          }
          return window.MoveoOne.instance;
        }
        
        var instance = new MoveoOneWeb(token);
  
        // Define allowed meta fields (libVersion is automatically included and protected)
        var allowedMetaFields = ["locale", "test", "appVersion", "calculateLatency"];
  
        // Validate and set only allowed meta values
        if (options) {
          for (var key in options) {
            if (options.hasOwnProperty(key) && allowedMetaFields.indexOf(key) !== -1) {
              instance.meta[key] = options[key];
            }
          }
        }
  
        // Initialize the instance
        instance.initialize();
  
        // Store instance globally for access
        window.MoveoOne.instance = instance;
  
        return instance;
      },

      // Get library version
      getVersion: function () {
        return LIB_VERSION;
      },

      // Global predict method - can only be called after initialization
      predict: function (modelId) {
        // Check if MoveoOne has been initialized
        if (!window.MoveoOne.instance) {
          return Promise.resolve({
            success: false,
            status: 'not_initialized',
            message: 'MoveoOne must be initialized before using predict method. Call MoveoOne.init() first.'
          });
        }

        // Validate modelId parameter
        if (!modelId || typeof modelId !== 'string' || modelId.trim() === '') {
          return Promise.resolve({
            success: false,
            status: 'invalid_model_id',
            message: 'Model ID is required and must be a non-empty string'
          });
        }

        var sessionId = window.MoveoOne.instance.sessionId;
        
        if (!sessionId) {
          return Promise.resolve({
            success: false,
            status: 'no_session',
            message: 'No active session found. Please ensure MoveoOne is properly initialized.'
          });
        }

        // Call the internal predict method asynchronously
        // This is non-blocking and won't affect website performance
        return window.MoveoOne.instance.internalPredict(modelId.trim(), sessionId);
      }

    };

})(window);
</script>

<script>
// Initialize MoveoOne with GTM variables
// Only token is required, others are optional with defaults
MoveoOne.init('{{MoveoOne Token}}', {
    appVersion: '1.0.0',  // Default version
    locale: 'en-US',      // Default locale
    test: 'false'         // Default test mode
});
</script>
